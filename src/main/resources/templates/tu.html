<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>tu</title>
</head>

<body>
<h1>3 图</h1>
<div>
    <h2>3.1 图简介</h2>
    <h3>3.1.1 基本概念</h3>
    <p>&nbsp;&nbsp;图（graph）：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。  </p>
    <p>&nbsp;&nbsp;顶点(Vertex)：图中的数据元素。线性表中我们把数据元素叫元素，树中将数据元素叫结点。  </p>
    <p>&nbsp;&nbsp;边：顶点之间的逻辑关系用边来表示，边集可以是空的。</p>
    <p>&nbsp;&nbsp;无向边(Edge)：若顶点V1到V2之间的边没有方向，则称这条边为无向边。</p>
    <p>&nbsp;&nbsp;无向图(Undirected graphs)：图中任意两个顶点之间的边都是无向边。（A,D）=（D,A）。</p>
    <p>&nbsp;&nbsp;有向边：若从顶点V1到V2的边有方向，则称这条边为有向边，也称弧(Arc)。用<V1,V2>表示，V1为狐尾(Tail)，V2为弧头(Head)。（V1，V2）≠（V2，V1）。</p>
    <p>&nbsp;&nbsp;有向图(Directed graphs)：图中任意两个顶点之间的边都是有向边。 （注意：无向边用“（）”，而有向边用“< >”表示。）</p>
    <p>&nbsp;&nbsp;有向完全图：有向图中，任意两个顶点之间都存在方向互为相反的两条弧。</p>
    <p>&nbsp;&nbsp;无向完全图：无向图中，任意两个顶点之间都存在边。</p>
    <p>&nbsp;&nbsp;稀疏图：有很少条边。</p>
    <p>&nbsp;&nbsp;稠密图：有很多条边。</p>
    <p>&nbsp;&nbsp;权（Weight）：与图的边或弧相关的数。</p>
    <p>&nbsp;&nbsp;网（Network）：带权的图。</p>
    <p>&nbsp;&nbsp;子图（Subgraph）：假设G=（V,{E}）和G‘=（V',{E'}），如果V'包含于V且E'包含于E，则称G'为G的子图。</p>
    <p>&nbsp;&nbsp;度（Degree）：无向图中，与顶点V相关联的边的数目。有向图中，入度表示指向自己的边的数目，出度表示指向其他边的数目，该顶点的度等于入度与出度的和。</p>
    <p>&nbsp;&nbsp;连通图：图中任意两个顶点都是连通的。</p>
    <p>&nbsp;&nbsp;连通分量：无向图中的极大连通子图。（子图必须是连通的且含有极大顶点数）。</p>
    <p>&nbsp;&nbsp;强连通分量：有向图中的极大强连通子图。</p>
    <p>&nbsp;&nbsp;生成树：无向图中连通且n个顶点n-1条边叫生成树。</p>
    <p>&nbsp;&nbsp;有向树：有向图中一顶点入度为0其余顶点入度为1。</p>
    <p>&nbsp;&nbsp;森林：一个有向图由若干棵有向树构成生成森林。</p>
    <h3>3.1.2 图的表示方法</h3>
    <p>&nbsp;&nbsp;（1）邻接矩阵：用两个数组，一个数组保存顶点集，一个数组保存边集，表示顶点相邻关系的一个N*N的方阵。</p>
    <p>&nbsp;&nbsp;（2）邻接表：数组与链表相结合的存储方法，采用链式结构存储图结构，顶点的邻接表由顶点的所有邻接点构成，图的邻接表由所有顶点的邻接表构成。</p>
    <h3>3.1.3 图的遍历方式</h3>
    <p>&nbsp;&nbsp;（1）深度优先遍历（DFS）：从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。</p>
    <p>&nbsp;&nbsp;（2）广度优先遍历（BFS）：类似于树的层次遍历。</p>
</div>

<div>
    <h2>3.2 图的最短路径</h2>
    <h3>3.2.1 基本概念</h3>
    <p>&nbsp;&nbsp;地图导航、城市交通图、站点之间最短路径等，这些问题都可以使用带权图描述如下：</p>
    <p>&nbsp;&nbsp;（1）源点：第一个顶点；</p>
    <p>&nbsp;&nbsp;（2）终点：最后一个顶点；</p>
    <p>&nbsp;&nbsp;（3）权值：所花的费用或时间等；</p>
    <p>&nbsp;&nbsp;（4）最短路径：源点与终点之间权值最小的路径。</p>
    <h3>3.2.2 分类</h3>
    <p>&nbsp;&nbsp;（1）单源最短路径问题：从某个固定源点出发，求这个源点到其他所有项点的最短距离。</p>
    <p>&nbsp;&nbsp;（2）多源最短路径问题：求任意两个顶点之间的最短距离。</p>
    <h3>3.2.3 Dijkstra算法</h3>
    <p>&nbsp;&nbsp;按照路径长度递增（非递减）的顺序产生最短路径。迪杰斯特拉算法适用于有向图和无向图。</p>
    <p>&nbsp;&nbsp;其具体过程为：</p>
    <p>&nbsp;&nbsp;（1）dist[1] V0到此顶点的最小路径长度；</p>
    <p>&nbsp;&nbsp;（2）dist[2] dist[3] dist[4] dist[5] dist[6]只能以S中的顶点作为中转而形成的路径中长度最短的路径长度。</p>
    <p>&nbsp;&nbsp;注意：保持从V0 到集合S中各顶点的最短路径长度都不可大于从V0到集合V-S中的任何顶点的最短路径长度。</p>
    <h3>3.2.4 多源路径问题</h3>
    <p>&nbsp;&nbsp;方法1：把单元最短路径算法调用v次，但是对于稠密图来讲效率不高；</p>
    <p>&nbsp;&nbsp;方法2：Floyd算法。</p>
    <p>&nbsp;&nbsp;特点：每一条最短路径不是一次确定，而是逐步形成，适用于用邻接矩阵存储的稠密图的多源路径最短问题。</p>
    <h3>3.2.5 8.5 Floyd算法基本思想</h3>
    <p>&nbsp;&nbsp;通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素b[i][j]，表示顶点i到顶点j经过了b[i][j]记录的值所表示的顶点。</p>
    <p>&nbsp;&nbsp;假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞，矩阵P的值为顶点b[i][j]的j的值。 接下来开始，对矩阵D进行N次更新。第1次更新时，如果”a[i][j]的距离” > “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”,更新b[i][j]=b[i][0]。同理，第k次更新时，如果”a[i][j]的距离” > “a[i][k-1]+a[k-1][j]”，则更新a[i][j]为”a[i][k-1]+a[k-1][j]”,b[i][j]=b[i][k-1]。更新N次之后，操作完成。</p>

</div>

<div>
    <h2>3.3 普利姆最小生成树方法（Prim算法）</h2>
    <h3>3.3.1 Prim算法基本思想</h3>
    <p>&nbsp;&nbsp;（1）将图中的顶点分成两个不同的顶点集S与V-S，将初始点加入到S集中；</p>
    <p>&nbsp;&nbsp;（2）在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中；</p>
    <p>&nbsp;&nbsp;（3）将该边的另一点加入到顶点集S中，并从V-S中删除；</p>
    <p>&nbsp;&nbsp;(4)重复步骤2-3，直到V-S为空。</p>
    <h3>3.3.2 Prim算法的基本步骤</h3>
    <p>&nbsp;&nbsp;（1）划分顶点集为S何V-S；</p>
    <p>&nbsp;&nbsp;（2）对于j∈V-S，定义closest[j]={k|min{c[i][k]|k∈S,j∈V-S}};</p>
    <p>&nbsp;&nbsp;（3）选择：针对k∈V-S，选择j={k|min{c[k][closest[k]]}};</p>
    <p>&nbsp;&nbsp;（4）修改：针对k∈V-S，修改其为closest[k];</p>
    <p>&nbsp;&nbsp;（5）重复3-4步骤，直到V-S=φ。</p>
    <h3>3.2.3 Prim算法的初始化</h3>
    <p>&nbsp;&nbsp;（1）除出发点V外，其余顶点均在V-S集中；</p>
    <p>&nbsp;&nbsp;（2）其余顶点的closest值均为出发点V;</p>
    <p>&nbsp;&nbsp;for(i=1;i<=n;i++)</p>
    <p>&nbsp;&nbsp;{</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;s[i]=0;</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;closest[i]=v;</p>
    <p>&nbsp;&nbsp;}</p>
    <p>&nbsp;&nbsp;s[v]=1;</p>

</div>

<div>
    <h2>3.4 克鲁斯卡尔最小生成树算法（Kruskal算法）</h2>
    <h3>3.4.1 Kruskal算法基本思想</h3>
    <p>&nbsp;&nbsp;（1）把图中的顶点看成n个不同的顶点集，每个顶点集都只含有1个顶点；</p>
    <p>&nbsp;&nbsp;（2）每次都在横跨不同顶点集的边中选择一条权值最小的边加入到最小生成树中；</p>
    <p>&nbsp;&nbsp;（3）直到图中所有的顶点都在同一个顶点集中为止。</p>

    <h3>3.4.2 Kruskal算法求解思路</h3>
    <p>&nbsp;&nbsp;（1）连通图的边按照权值从小到大进行排列；</p>
    <p>&nbsp;&nbsp;（2）依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中，不是，则不加入生成树中。</p>

</div>

<div>
    <form action="/data" method="post">
        <input style=" background-color:rgb(0,0,255)" type="submit"  value="返回">
    </form>
    <h2 th:utext="${msg1}"></h2>
</div>

</body>

   <style>
     p{
         font-family:宋体;
         font-size:20px;
       }
   </style>
</html>