<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>paixu</title>
</head>

<body>
<h1>4 排序</h1>
    <div>
        <h2>4.1 排序的基本概念和方法</h2>
            <h3>4.1.1 排序的基本概念</h3>
        <p>&nbsp;&nbsp;设有{R1,R2,...,Rn}是由n个记录组成的文件，{k1,k2,...,kn}是相应的排序码的集合。排序是将记录按排序码不增（或不减）的次序排列起来的运算。计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。 排序算法的稳定性：键值相等的记录排序后保持原来的顺序则稳定，否则不稳定。   </p>
            <h3>4.1.2 排序的分类</h3>
            <p>&nbsp;&nbsp;（1）按待排序文件规模的大小分类： </p>
            <p>&nbsp;&nbsp;&nbsp;①内部排序：在内部进行的排序；</p>
            <p>&nbsp;&nbsp;&nbsp;②外部排序：在外存设备上进行的排序。</p>
            <p>&nbsp;&nbsp;（2）排序方法的分类：</p>
            <p>&nbsp;&nbsp;&nbsp;①插入类，如直接插入排序、折半插入排序、2-路插入排序、希尔排序；</p>
            <p>&nbsp;&nbsp;&nbsp;②交换类：冒泡排序、快速排序；</p>
            <p>&nbsp;&nbsp;&nbsp;③选择类：简单选择排序、锦标赛排序、堆排序</p>
            <p>&nbsp;&nbsp;&nbsp;④归并类：归并排序；</p>
            <p>&nbsp;&nbsp;&nbsp;⑤其他方法：基数排序。</p>
            <h3>4.1.3 待排序记录的存储方式</h3>
            <p>&nbsp;&nbsp;在排序的过程中通常需进行下列两种基本操作</p>
            <p>&nbsp;&nbsp;（1）比较两个关键字的大小；</p>
            <p>&nbsp;&nbsp;（2）将记录的从一个位置移动到另一个位置。</p>
            <p>&nbsp;&nbsp;待排序记录可有以下三种存储方式：</p>
            <p>&nbsp;&nbsp;（1）待排序的一组记录存放在地址连续的一组存储单元数；</p>
            <p>&nbsp;&nbsp;（2）一组待排序的记录放在静态链表中，记录之间的次序关系由指针实现；</p>
            <p>&nbsp;&nbsp;（3）待排序记录本身存储在一组地址连续的存储单元内，同时有另一个指示各个记录存储位置的地址向量。</p>
            <h3>4.1.4 排序算法效率的指标</h3>
            <p>&nbsp;&nbsp;评价排序算法好坏的标准：</p>
            <p>&nbsp;&nbsp;（1）算法执行时所需要的时间（最重要的标准）；</p>
            <p>&nbsp;&nbsp;（2）执行算法所需要的附加空间。</p>

    </div>

    <div>
        <h2>4.2 直接插入排序</h2>
            <p>&nbsp;&nbsp;直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。 </p>
            <p>&nbsp;&nbsp;因此，直接插入排序可以用两个循环完成：</p>
            <p>&nbsp;&nbsp;第一层循环：遍历待比较的所有数组元素；</p>
            <p>&nbsp;&nbsp;第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。</p>
    </div>

    <div>
    <h2>4.3 冒泡排序</h2>
    <p>&nbsp;&nbsp;每次都是相邻的两个数进行比较，较大者交换到后一个位置。对n个数的排序进行n-1此比较厚最大者被交换到了最后一个位置，这样就完成了一趟冒泡排序。如下图2.2所示。 </p>
    </div>

<div>
    <h2>4.4 拓扑排序</h2>
    <h3>4.4.1 基本概念</h3>
    <p>&nbsp;&nbsp;有向无环图：一个无环的有向图；其作用是描述一项工程或系统的进行过程。 </p>
    <p>&nbsp;&nbsp;AOV网：顶点表示活动，用有向边表示活动之间的优先关键的有向图。 </p>
    <p>&nbsp;&nbsp;（1）不允许出现环，这意味着某项活动应以自己为先决条件；</p>
    <p>&nbsp;&nbsp;（2）若<Vi，Vj>是图中有向边，则Vi是Vj的直接前驱，Vj是Vi的直接后继。</p>
    <p>&nbsp;&nbsp;拓扑排序：将AOV网中所有的顶点按照他们之间的相互关系的优先顺序排成一个线性序列的过程。 </p>
    <p>&nbsp;&nbsp;拓扑序列：拓扑排列所得到的序列。</p>
    <h3>4.4.2 拓扑排序方法</h3>
    <p>&nbsp;&nbsp;（1）在有向图中选一个没以前驱的顶点且输出；</p>
    <p>&nbsp;&nbsp;（2）从图中删除该顶点和所有以它为尾的弧；</p>
    <p>&nbsp;&nbsp;（3）重复上述两步，直到全部顶点均已经输出；或者当图中不存在无前驱的结点为止。</p>
    <p>&nbsp;&nbsp;拓扑排序的过程就是判断一个图是否有环的过程。</p>
</div>

<div>
    <h2>4.5 快速排序</h2>
    <h3>4.5.1 基本概念</h3>
    <p>&nbsp;&nbsp;先从待排序序列中找一个元素作为中心点或者说界点，比如选第一个元素。设这个中心点为y。序列中的其他元素与y进行比较，大于等于y的放在它的右边，小于y的放在它的左边。然后再对两个子序列递归的快速排序，直到每个子序列只剩一个元素。 </p>
    <h3>4.5.2 算法分析</h3>
    <p>&nbsp;&nbsp;时间复杂度：</p>
    <p>&nbsp;&nbsp;（1）最好：划分后，左侧右侧子序列的长度相同，时间复杂度为O（nlog2n）</p>
    <p>&nbsp;&nbsp;（2）最坏：就是待排序列已经排好的情况下，每次取界点都是第一个元素，这种情况下，每次划分只能得到一个比上一次少一个记录的子序列，时间复杂度为O（n2）。</p>
    <p>&nbsp;&nbsp;平均情况下，时间复杂度为O（nlog2n）</p>
</div>

<div>
    <h2>4.6 简单选择排序</h2>
    <p>&nbsp;&nbsp;首先，从待排序序列中选出最小者并交换到第一个位置（第一次选择最小者）；接下来，从盛夏的未排序序列中选出最小者并交换到第二个位置（第二次选择第二小）；一次类推，对于含n个元素的序列进行n-1次选择之后就排好序了。</p>

</div>

<div>
    <h2>4.7 堆排序</h2>
    <h3>4.7.1 基本思想</h3>
    <p>&nbsp;&nbsp;每个节点都不大于或者都不小于它的子节点的完全二叉树。 </p>
    <h3>4.7.2 堆排序过程</h3>
    <p>&nbsp;&nbsp;（1）建立初始堆；</p>
    <p>&nbsp;&nbsp;（2）输出堆顶元素，并以最后一个元素代替堆顶元素；</p>
    <p>&nbsp;&nbsp;（3）将剩余的n-1个元素在调整成一个堆；</p>
    <p>&nbsp;&nbsp;（4）输出堆顶元素，并以最后一个元素代替堆顶元素。</p>
    <h3>4.7.3 算法分析</h3>
    <p>&nbsp;&nbsp;（1）时间效率：O（nlog2n）；</p>
    <p>&nbsp;&nbsp;（2）空间效率：0(1)；</p>
    <p>&nbsp;&nbsp;（3）稳定性：不稳定；</p>
    <p>&nbsp;&nbsp;（4）适用于n较大的情况。</p>
</div>

<div>
    <h2>4.8 归并排序</h2>
    <h3>4.8.1 基本思想</h3>
    <p>&nbsp;&nbsp;将两个或两个以上的有序表组合成一个新有序表。</p>
    <p>&nbsp;&nbsp;（1）初始无序序列看成n个有序子序列，每个子序列长度为1；</p>
    <p>&nbsp;&nbsp;（2）两两合并，得到n/2个长度为2或1的有序子序列；</p>
    <p>&nbsp;&nbsp;（3）重复步骤2直至得到一个长度为n的有序序列为止。</p>
    <h3>4.8.2 算法分析</h3>
    <p>&nbsp;&nbsp;（1）时间效率：O（nlog2n）；</p>
    <p>&nbsp;&nbsp;（2）空间效率：0(n)；</p>
    <p>&nbsp;&nbsp;（3）稳定性：不稳定；</p>
</div>

<div>
    <h2>4.9 基数排序</h2>
    <h3>4.9.1 基本思想</h3>
    <p>&nbsp;&nbsp;待排序序列中，每个元素都有d个数值组成，每个数值的可能取rd个值。从最低位数值开始，根据每个数值的不同将待排序列中的元素分配到rd个队列中，然后再收集，重复d次，完成排序。</p>
    <h3>4.9.2 算法分析</h3>
    <p>&nbsp;&nbsp;（1）时间效率：O（d(n+rd）；</p>
    <p>&nbsp;&nbsp;（1）空间效率：0（n+rd）</p>
    <p>&nbsp;&nbsp;（3）稳定性：不稳定；</p>
</div>

<div>
    <form action="/data" method="post">
        <input style=" background-color:rgb(0,0,255)" type="submit"  value="返回">
    </form>
    <h2 th:utext="${msg1}"></h2>
</div>


</body>

  <style>
    p{
        font-family:宋体;
        font-size:20px;
    }
   </style>
</html>